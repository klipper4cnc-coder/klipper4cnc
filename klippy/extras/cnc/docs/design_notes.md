# CNC Design Notes

This document captures design rationale, tradeoffs, and non-obvious decisions
in the CNC subsystem. It is intended for contributors who want to modify or
extend the system and need to understand *why* things are the way they are,
not just *what* they do.

This document intentionally overlaps with code comments and architecture.md,
but focuses on intent, constraints, and future direction.

---

## Why this subsystem exists

Klipper is fundamentally a motion planner and executor, not a CNC interpreter.
Rather than modifying Klipper internals, this CNC system is designed as:

- A layered interpreter on top of Klipper
- Explicit in execution and state transitions
- Easy to reason about and debug
- Removable without affecting core Klipper behavior

This drives many of the architectural choices below.

---

## Streaming-first design

### Why streaming is the primary execution model

CNC jobs can be large:
- Tens or hundreds of thousands of lines
- Generated by CAM tools
- Not easily loaded fully into memory on embedded systems

Streaming execution allows:
- Low memory usage
- Incremental interpretation
- Early job start
- Easier pause / resume semantics

The controller’s lookahead buffer decouples:
- Interpretation speed
- Execution speed

This avoids hard real-time coupling between parsing and motion.

---

## Why arcs are segmented early

Klipper does not natively execute arcs.

Instead of:
- Teaching Klipper about arcs
- Passing arc semantics deeper into the system

This design chooses to:
- Resolve arcs completely in the interpreter
- Convert them into linear motion primitives
- Treat arcs as a *geometry problem*, not an execution problem

Benefits:
- Executor stays simple
- Motion backend remains interchangeable
- Debugging is easier (everything is linear by execution time)

Cost:
- Potentially large primitive counts
- But segmentation tolerance is configurable

This is a deliberate tradeoff.

---

## Why motion primitives are immutable and simple

MotionPrimitive objects:
- Carry no modal state
- Carry no interpretation context
- Represent exactly one motion

Once created, they should be treated as immutable.

This ensures:
- Execution is deterministic
- Progress and ETA calculations are stable
- Executors never need to ask “what does this mean?”

All meaning is resolved upstream.

---

## Modal state isolation

All modal CNC state lives in CNCModalState.

This avoids:
- Hidden global state
- Executor-side assumptions
- Interpreter/controller coupling

The interpreter is the *only* component that mutates modal state.
The controller and executor only consume resolved output.

This separation is intentional and should be preserved.

---

## Distance-based progress reporting

Progress tracking is based on *actual motion length*, not:

- Line count
- Primitive count
- Elapsed wall-clock time

Why:
- Different primitives represent wildly different distances
- Feedrate changes affect execution time
- Arc segmentation inflates primitive count

Distance-based tracking:
- Is geometry-accurate
- Matches user expectations
- Produces stable ETAs

This is why prescan_total_length() exists.

---

## Prescan vs runtime interpretation

Prescan uses:
- A fresh, isolated modal state
- The same interpreter logic
- No execution

Runtime uses:
- A separate modal state
- Streaming interpretation
- Execution side effects

These must remain separate.

Mixing prescan and runtime state would cause:
- Incorrect arc segmentation
- Incorrect modal resolution
- Incorrect progress reporting

Duplication here is intentional.

---

## Why SoftLimits are software-only

SoftLimits are:
- Checked before execution
- Enforced via exceptions
- Not real-time clamps

This is by design.

Real-time safety belongs to:
- Firmware limits
- Hardware endstops
- Klipper’s own safety systems

SoftLimits exist to:
- Catch CAM or G-code errors early
- Prevent obviously invalid motion
- Fail fast and loudly

They are not a safety system.

---

## Why the controller is stateful and explicit

The controller has an explicit state machine:

- IDLE
- RUNNING
- HOLD
- CANCELLED

This avoids:
- Implicit behavior
- Hidden transitions
- “magic” resume logic

Feed hold and resume are:
- Explicit
- Predictable
- Testable

Cancellation is terminal until reset.
This prevents undefined partial states.

---

## Lookahead buffer sizing

The lookahead buffer exists to:
- Smooth execution
- Avoid interpreter starvation
- Decouple file I/O from motion

The current size is intentionally conservative.

Future tuning may:
- Make it configurable
- Adapt it dynamically
- Base it on motion planner feedback

But correctness is prioritized over throughput.

---

## Why there are two program abstractions

PrimitiveProgram and CNCProgram both exist.

This reflects evolution, not ideal design.

Currently:
- Streaming execution bypasses program objects entirely
- Program objects are mainly used for tests and experimentation

Long-term, one of the following should happen:
- Remove one abstraction
- Unify them
- Make streaming the only supported path

Until then, both exist intentionally.

---

## Test files as executable documentation

The test files are not strict unit tests.

They are:
- Usage examples
- Integration sketches
- Sanity checks

They trade:
- Formal isolation
for:
- Readability
- Architectural clarity

This is intentional.

---

## Things that are intentionally missing

The following are not implemented on purpose:

- Tool changes (M6)
- Spindle control (M3/M4/M5)
- Coolant control
- G10 work offset setting
- Cutter radius compensation
- Canned cycles

These features add:
- State complexity
- Real-time coupling
- Machine-specific behavior

They should only be added once the core execution model is stable.

---

## Rules for future contributors

If you modify this system:

- Do not add modal state outside CNCModalState
- Do not let executors interpret G-code
- Do not pass arcs past the interpreter
- Do not mix prescan and runtime state
- Prefer explicit state transitions over implicit behavior
- Favor correctness and debuggability over performance

Violating these rules will make the system harder to reason about.

---

## Final note

This CNC subsystem is intentionally conservative.

It favors:
- Clear data flow
- Explicit control
- Early error detection
- Simple execution backends

If something feels “overly explicit”, that is likely intentional.
