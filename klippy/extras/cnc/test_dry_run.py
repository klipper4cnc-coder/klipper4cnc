#!/usr/bin/env python3
# klippy/extras/cnc/test_dry_run.py
#
# Run from repo root:
#   python3 klippy/extras/cnc/test_dry_run.py --file klippy/extras/cnc/test.nc
#
# Or run with an autogenerated tiny program:
#   python3 klippy/extras/cnc/test_dry_run.py

import os
import sys
import argparse
import tempfile
import math
from collections import Counter

# Ensure local (non-package) imports inside klippy/extras/cnc work
THIS_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, THIS_DIR)

from streamer import GCodeStreamer
from parser import parse_gcode_line

from modal_state import CNCModalState
from interpreter import CNCInterpreter
from planner import CNCPlanner
from controller import CNCController
from limits import SoftLimits, SoftLimitError


class DryRunExecutor:
    """Executor that records primitives instead of moving hardware."""
    def __init__(self):
        self.executed = []
        self.last_feedrate = None
        self.total_len = 0.0

        self._motion_counts = Counter()
        self._min_seg = None
        self._max_seg = 0.0
        self._sum_seg = 0.0

    def execute(self, p):
        # Controller already enforces feedrate != None at execution time.
        self.executed.append(p)
        self.last_feedrate = p.feedrate

        L = p.length()
        self.total_len += L

        # Stats
        self._motion_counts[getattr(p.motion, "value", str(p.motion))] += 1
        self._sum_seg += L
        self._max_seg = max(self._max_seg, L)
        self._min_seg = L if self._min_seg is None else min(self._min_seg, L)

    def flush(self):
        pass

    def stats(self):
        n = len(self.executed)
        avg = (self._sum_seg / n) if n else 0.0
        return {
            "count": n,
            "total_len_mm": self.total_len,
            "min_seg_mm": self._min_seg if self._min_seg is not None else 0.0,
            "max_seg_mm": self._max_seg,
            "avg_seg_mm": avg,
            "motion_counts": dict(self._motion_counts),
        }


def make_temp_program():
    # Small and safe: a couple linears + a small CW arc in XY plane.
    # Starts at (0,0,0). Uses mm, absolute.
    prog = """\
G21
G90
G1 F300
G1 X1.0 Y0.0
G1 X1.0 Y1.0
G2 X0.0 Y1.0 I-0.5 J0.0 F300
G1 X0.0 Y0.0
"""
    fd, path = tempfile.mkstemp(prefix="cnc_dry_", suffix=".nc", text=True)
    os.close(fd)
    with open(path, "w") as f:
        f.write(prog)
    return path


def _print_context(line_num, raw, state, p):
    # Modal context
    abs_mode = "G90" if getattr(state, "absolute", True) else "G91"
    units = getattr(state, "units", "?")
    plane = getattr(state, "plane", "?")
    motion = getattr(getattr(p, "motion", None), "value", str(getattr(p, "motion", "?")))
    feed = getattr(p, "feedrate", None)

    print("\n[DRY][FAIL] soft limit violation")
    print(f"  line: {line_num}")
    print(f"  gcode: {raw}")
    print(f"  modal: {abs_mode} {plane} {units}")
    print(f"  prim:  {motion} start={p.start} end={p.end} F={feed}")


def run_dry(filepath, *, verbose=False, validate_per_primitive=True):
    # Soft limits (tweak as you like)
    limits = SoftLimits({
        "X": (-310.0, 310.0),
        "Y": (-310.0, 310.0),
        "Z": (-110.0, 110.0),
    })

    state = CNCModalState()
    interp = CNCInterpreter(state, soft_limits=limits)

    # Planner defaults: conservative for dry-run
    planner = CNCPlanner(
        max_velocity=150.0,
        max_accel=1000.0,
        junction_deviation=0.05,
        buffer_time=0.25,
        keep_tail_moves=2,
        max_window_moves=200,
    )

    execu = DryRunExecutor()
    ctrl = CNCController(execu, program=None, planner=planner)

    streamer = GCodeStreamer(filepath)

    ctrl.reset()
    ctrl.start()

    # Prefer pump-style stepping if your controller has it (post-refactor)
    if hasattr(ctrl, "pump") and hasattr(ctrl, "is_done"):
        streamer.open()
        try:
            # We'll track line numbers ourselves by reading some lines to validate,
            # but still feed the controller via pump().
            #
            # To keep this drop-in without rewriting controller internals:
            # - We run pump() normally.
            # - If validate_per_primitive is enabled, we do a second streaming pass
            #   afterwards to locate the exact failing line if needed.
            while True:
                ctrl.pump(streamer, interp, max_lines=50, max_steps=50)
                if ctrl.is_done():
                    break
        finally:
            streamer.close()
    else:
        # Old controller path
        ctrl.run_stream(streamer, interp)

    ctrl.flush()

    # Validation with useful context:
    # - Fast path: check executed primitives (what you already had)
    # - If a violation occurs, do a second pass through the file to find the first
    #   offending primitive and print the line context.
    try:
        for p in execu.executed:
            limits.check_primitive(p)
    except SoftLimitError:
        if not validate_per_primitive:
            raise

        # Second pass to locate line and primitive context
        line_num = 0
        streamer2 = GCodeStreamer(filepath)
        streamer2.open()
        try:
            while True:
                raw = streamer2.next_line()
                if raw is None:
                    break
                line_num += 1
                parsed = parse_gcode_line(raw)
                prims = interp.interpret(parsed)
                for p in prims:
                    try:
                        limits.check_primitive(p)
                    except SoftLimitError as e:
                        _print_context(line_num, raw, state, p)
                        raise e
        finally:
            streamer2.close()

        # If somehow not found, re-raise original
        raise

    if verbose:
        st = execu.stats()
        print(f"[DRY] executed={st['count']} total_len_mm={st['total_len_mm']:.3f}")
        print(f"[DRY] seg_len_mm min={st['min_seg_mm']:.5f} avg={st['avg_seg_mm']:.5f} max={st['max_seg_mm']:.5f}")
        print(f"[DRY] motion_counts={st['motion_counts']}")
        if execu.executed:
            print(f"[DRY] last_end={execu.executed[-1].end} last_F={execu.last_feedrate}")

    return execu


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--file", default=None, help="Path to .nc/.gcode file")
    ap.add_argument("--verbose", action="store_true")
    ap.add_argument("--no-context-pass", action="store_true",
                    help="Don't do a second pass to print line context on soft-limit failure")
    args = ap.parse_args()

    temp_path = None
    try:
        path = args.file
        if path is None:
            temp_path = make_temp_program()
            path = temp_path
            print(f"[DRY] using temp file: {path}")

        if not os.path.exists(path):
            print(f"[DRY] file not found: {path}")
            sys.exit(2)

        try:
            execu = run_dry(path, verbose=args.verbose, validate_per_primitive=not args.no_context_pass)
        except SoftLimitError as e:
            # If we found context, it was already printed above
            print(f"[DRY][FAIL] soft limit violation: {e}")
            sys.exit(1)
        except Exception as e:
            print(f"[DRY][FAIL] exception: {e}")
            raise

        if len(execu.executed) == 0:
            print("[DRY][FAIL] no primitives executed (job produced no motion?)")
            sys.exit(1)

        st = execu.stats()
        print(f"[DRY][PASS] executed {st['count']} primitives, {st['total_len_mm']:.3f}mm total")
        if args.verbose:
            print(f"[DRY] seg_len_mm min={st['min_seg_mm']:.5f} avg={st['avg_seg_mm']:.5f} max={st['max_seg_mm']:.5f}")
            print(f"[DRY] motion_counts={st['motion_counts']}")
        sys.exit(0)

    finally:
        if temp_path and os.path.exists(temp_path):
            os.remove(temp_path)


if __name__ == "__main__":
    main()